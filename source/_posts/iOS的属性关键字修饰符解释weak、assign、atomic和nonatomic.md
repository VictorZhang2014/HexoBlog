---
title: iOS的属性关键字修饰符解释weak、assign、atomic和nonatomic等
date: 2017-08-01 19:50:58
tags: iOS修饰符,weak,assign
categories: iOS
---

`weak`
- 只能修饰派生自`NSObject`类或协议，因为`NSObject`即是类，也是协议
- 在对象的引用计数器为0时，对象的指针`会`自动`指向nil`
- 可以解决循环引用问题

`assign`
- 可以修饰基础数据类型，也可以修饰派生自`NSObject`类的对象
- 在对象的引用计数器为0时，对象的指针`不会`自动`指向nil`
- 可以解决循环引用问题

`atomic`
- 是Objective-C默认修饰的
- 原子性的
- 之所以线程安全，是因为只能编译器在生成`setter`和`getter`时，方法内部会有一个`@synchronized()`的同步互斥锁
- 线程不安全，是因为在多线程中操作对象时，比如：`NSArray`的`addObject:`方法，它是没有锁的，所以为了保证安全，我们必须自己加锁
- 速度慢

`nonatomic`
- 不是Objective-C默认修饰的，需要手动添加
- 非原子性
- 线程不安全
- 速度快

`strong`
- `Objective-C`对象默认创建时，就是强引用
- 修饰`Objective-C`对象的，创建时为引用计数为1
- 不管是修饰可变属性还是不可变属性，只要使用了赋值号，就是增加了一个指针指向同一块内存地址

`copy`
- 修饰不可变属性时，是浅拷贝，意思是：只要使用了赋值号，就是增加了一个指针指向同一块内存地址
- 修饰可变属性时，是深拷贝，意思是：只要使用了赋值号，就是新开辟了一块内存空间

`__block`
- 默认情况下，局部变量只可以被block访问
- 但是用它来修饰局部变量，就可以在block代码块里修改局部变量的值，因为这个局部变量被拷贝了一份到block代码块里，如果是指针就是拷贝了一份指针

`__weak`
- 就是将OC的对象改变成弱引用指针

**注意**
一个`block代码块`是否会造成循环引用要看这个`block`所属的类是对这个`block`什么修饰，如果是`strong`和`copy`，则这个`block代码块`一定是强引用，且在外部使用这个block代码块时，使用`self`，就一定要转换成`__weak`形式；或者在这个`block`所属的类里对这个block修饰为`assign`或者`weak`，则在外部使用这个`block代码块`时，`self`不用转换为`__weak`形式。

